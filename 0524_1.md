# [23.05.24] 코드스테이츠 (FE) 45기_DAY 31_1

# Unit7 <br><br>👩🏻‍💻 Chapter 1. 웹 애플리케이션 아키텍처

## ✔️ 클라이언트 - 서버 아키텍처

<br>

클라이언트 - 서버 아키텍처, 다른말로는 2티어 아키텍처라고 불리는 설계 방식에 대해 알아봅시다.

스마트폰에서 쇼핑몰 앱을 사용해 본 경험이 있는가? 혹시 인터넷 연결이 없는 쇼핑몰은 잘 작동할까? 인터넷 연결이 없다면 쇼핑몰 앱은 정상적으로 동작할 수 없다. 그 이유는 상품 정보를 인터넷 어딘가에 존재하는 서버로부터 받아오기 때문이다.

서버는 영어 단어 그대로 제공(serve)하는 주체이다.

판매하려는 상품 정보가 전부 앱 안에 담긴 경우를 가정해보자. 현실에서 이런 경우는 없지만, 만약 앱과 연결된 서버가 존재하지 않는다면 어떤 문제가 생길까?

=> 이 경우에는 끊임없이 앱을 업데이트 해야한다.

이렇게 상품 정보 같은 리소스가 존재하는 곳과 리소스를 사용하는 앱을 분리시킨 것을 2티어 아키텍처, 또는 클라이언트-서버 아키텍처라고 부른다.
리소스를 사용하는 앱이 바로 "클라이언트", 리소스를 제공(serve)하는 곳은 "서버" 라고 부른다.

일반적으로 서버는 리소스를 전달해주는 역할만 담당한다. 리소스를 저장하는 공간을 별도로 마련해 두는데 이 공간을 "데이터베이스" 라고 부른다. 데이터베이스는 창고와 같은 역할을 한다.

이처럼 기존 2티어 아키텍처에 데이터베이스가 추가된 형태를 3티어 아키텍처라고 부른다.

마지막으로, 클라이언트와 서버의 종류를 알아보자.

클라이언트는 보통 플랫폼에 따라 구분된다. 브라우저를 통해 주로 이용하는 웹 플랫폼에서의 클라이언트는 웹사이트 또는 웹 앱이라고 부른다.

iOS나 안드로이드와 같은 스마트폰/태플릿 플랫폼, 그리고 윈도우와 같은 데스크탑 플랫폼에서 이용하는 앱 역시 클라이언트가 될 수 있다.

<br>

## ✔️ 클라이언트 - 서버 통신과 API

<br>

클라이언트와 서버가 어떤 식으로 통신하는지, 그리고 이때 등장하는 API 라는 것은 무엇을 의미하는지 알아보자.

상점의 상품 제공자와 손님의 관전에서 살펴보자. 적절한 예를 들기 위해 커피 전문점을 예로 들어보겠다. 클라이언트와 서버 간의 통신은 요청과 응답으로 구성된다. 요청이 있어야만 응답이 온다.

주문하지 않은 커피가 갑자기 나올수도 있겠지만, 보통은 손님으로부터 주문이 들어가야 커피가 나온다.

클라이언트-서버 아키텍처에서는 서버 마음대로 클라이언트에 리소스를 전달하지 않는다.

클라이언트와 서버 간의 통신을 알아 보려면, 먼저 프로토콜이라는 개념을 이해해야한다.

=> 프로토콜은 통신규약, 즉 약속이다.

### 웹 애플리케이션 프로토콜 : HTTP

웹 애플리케이션 아키텍처에서는 클라이언트와 서버가 서로 HTTP라는 프로토콜을 이용해서 서로 대화를 나눈다. HTTP를 이용해 주고받는 메시지는 "HTTP 메시지" 라고 부른다.

실제로 우리가 커피를 주문할때에 직접 주문하거나, 앱을 이용하거나, 키오스크를 이용할 수도 있다. 이러한 방법 하나하나 전부 프로토콜이다. 같은 일을 하기 위해 "다양한 방법"이 존재할 수 있는 것이다.

한편 "규약"이라는 측면에서 프로토콜을 이해해보자.

![](./capture/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-05-24%20%EC%98%A4%EC%A0%84%2012.45.09.png)

OSI7 Layers는 컴퓨터공학과 네트워크에서 자주 등장하는 개념이다. 해당 프로토콜이 어떤 계층에 속해있는지를 표시하고 있다.

### API (Application Programming Interface)

API가 무엇인지 알아보자.

서버에는 마치 식당에서 메뉴판을 제공하듯, 리소스를 잘 활용할 수 있도록 인터페이스룰 제공해야 한다. 이것을 API라고 한다.

API는 Application Programming Interface의 약자이며, Interface의 사전적 의미는"의사소통이 가능"하도록 만들어진 "접점"을 의미한다. 

서버가 리소스 전달을 위한 API를 잘 구축해놓아야 클라이언트가 이를 활용할 수 있다. 
보통 인터넷에 있는 데이터를 요청할때에는 HTTP라는 프로토콜을 사용하며, 주소(URL,URI)를 통해 접근할 수 있게 된다.

아래는 스타벅스 API 서버가 제공하는 적절한 URL디자인 예제를 첨부한다. 파라미터를 사용하기 위해 물음표와 & 기호를 사용하는 것을 참고하자.

![](/capture/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-05-24%20%EC%98%A4%EC%A0%84%201.00.40.png)

HTTP API디자인에는 Best Practice가 존재한다. 스타벅스 예제와는 다르게, 실제로 쓰일법한 API를 소개한다. 사용자 관리 API인데 URL디자인은 비교적 단순하나 "메서드" 라는 개념이 등장한다.

HTTP 요청에는 메서드라는 것이 존재한다. 앞서 스타벅스에서는 리소스를 그저 달라고(GET) 요청했지만, 사용자 관리 API에서는 사용자를 추가해달라고(CREATE) 요청하거나, 지워달라고(DELETE) 요청할 수도 있다. CURD 각각의 행동과 일치하는 HTTP 메서드의 종류가 존재한다.

![](/capture/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-05-24%20%EC%98%A4%EC%A0%84%201.00.47.png)

우리가 기억해야 할 다섯가지 메서드는 다음과 같다. GET, POST, PUT (또는PATCH), DELETE

각각 조회, 추가, 갱신, 삭제와 관련이 있다. 메서드 설명은 MDN "HTTP 요청 메서드"를 참고하자.

=> https://developer.mozilla.org/ko/docs/Web/HTTP/Methods

이때 HTTP 메서드는 리소스를 이용하여, 하려는 행동에 맞게 적절하게 써야 한다는 점에 주의해야 한다. 만일 GET 요청을 했는데 갑자기 서버에서 리소스가 지워진다면 좋은 API 디자인이라고 볼 수 없다.

![](/capture/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-05-24%20%EC%98%A4%EC%A0%84%201.00.53.png)

<br>

# 👩🏻‍💻 Chapter 2. 브라우저의 작동 원리(보이지 않는 곳)

## ✔️ URL 과 URI

브라우저의 주소창에 입력한 URL은 서버가 제공되는 환경에 존재하는 파일의 위치를 나타낸다. 예를들어 `https://codestates.com:443/` 사이트에 접속하게 되면, codestates.com 주소가 가리키는 서버의 기본 폴더를 뜻한다. CLI 환경에서 폴더와 파일의 위치를 찾아 이동하듯이, 슬래시 (/)를 이용해 서버의 폴더에 진입하거나 파일을 요청할 수 있다. 그러나 기본적인 보안의 일환으로 외부에서 직접 접근이 가능한 경우는 거의 없다. 크롬 브라우저에 다음 url을 입력해보자.

```
# 크롬 브라우저에 입력하면, 브라우저로 PC의 폴더와 파일을 탐색할 수 있다.

# username에는 사용자 이름을 입력합니다.
# mac OS:
file://127.0.0.1/Users/username/Desktop/
```

URL의 각 부분이 무엇을 나타내는지 살펴보자.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/ojobFNePZ-1620216374688.png)

URL은 Uniform Resource Locator의 줄임말로, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타낸다.

URL은 scheme, hosts, url-path로 구분할 수 있다. 가장먼저 작성하는 scheme는 통신방식(프로토콜)을 뜻한다. 일반적인 우브라우저에서는 http(s) 를 사용한다. hosts는 웹 서버의 이름이나 도메인, IP를 사용하며 주소를 나타낸다. url-path는 웹 서버에서 지정한 루트 디렉토리로부터 시작하여 웹 페이지, 이미지, 동영상 등이 위치한 경로와 파일명을 나타낸다.

URI는 Uniform Resource Identifier의 줄임말로, 일반적으로 URL의 기본 요소인 scheme, hosts,url-path에 더해 query, fragment를 포함한다. query는 웹 서버에 보내는 추가적인 질문이다. 위 그림의 `http://www.google.com:80/search?q=JavaScript` 를 브라우저의 검색창에 입력하면, 구글에서 JavaScript를 검색한 결과가 나타난다. fragment는 일종의 북마크 기능을 수행하며 URL에 fragment(#)와 특정 HTML요소의 id를 전달하면 해당 요소가 있는 곳으로 스크롤을 이동할 수 있다.

브라우저의 검색창을 클릭하면 나타나는 주소가 URI이다. URI는 URL을 포함하는 상위개념이다.

| 부분 | 명칭 | 설명 |
|:----------|:----------:|----------:|
| `file://`, `http://`, `thhps://` | scheme | 통신 프로토콜 |
| `127.0.0.1`,`www.google.com` | hosts | 웹 페이지, 이미지, 동영상 등의 <br>파일이 위치한 웹 서버, 도메인 또는 IP |
| `:80`,`:443`,`:3000` | port | 웹 서버에 접속하기 위한 통로 |
| `/search`, `/Users/username/Desktop` | url-path | 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상등의 파일이 위치까지의 경로
|`q=JavaScript` | query | 웹 서버에 전달하는 추가 질문|

* `127.0.0.1` 은 로컬 PC를 나타낸다.
* port는 서버로 진입할 수 있는 통로이다.

<br>

## ✔️ IP와 포트

<br>

### IP address

네트워크에 연결된 특정 PC의 주소를 나타내는 체계를 IP address(Internet Protocol address, IP주소) 라고 한다. 인터넷에 연결된 모든 PC 는 IP주소체계를 따라 네 덩이의 숫자로 구분된다. 이렇게 네 덩이의 숫자로 구분된 IP주소체계를 IPv4라고 한다. IPv4는 Internet Protocol version 4의 줄임말로, IP주소체계의 네 번째 버전을 뜻한다.

터미널에서 간단한 명령어로, 자주 이용하는 코드스테이츠의 IPv4주소를 확인할 수 있다. 터미널을 열고, `nslookup codesatates.com`을 입력하면, 다음과 같은 화면을 볼 수 있다.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/lgpHkO1Ss-1620218482070.png)

IPv4는 각 덩어리마다 0부터 255까지 나타낼 수 있다. 따라서 2^(32)인 약 43억개의 IP주소를 표현할 수 있다. 그중에서 몇 가지는 이미 용도가 정해져 있다. 특히 다음과 같은 IP주소는 반드시 기억해야 한다.

* `localhost`,`127.0.0.1` : 현재 사용 중인 로컬 PC를 지칭한다.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/YAeqY4nGh-1620218696001.jpeg)

개인 PC의 보급으로, 각종 서비스를 위해 서버를 생산하면서 IPv4로 할당할 수 있는 PC가 한계를 넘어서게되어 IPv6가 나오게 되었다. IPv6는 표기법을 달리 책정하여 2^(128)개의 IP주소를 표현할 수 있다.

### PORT

터미널에서 리액트를 실행하면 나타나는 화면에는, 로컬 PC의 IP주소인 `127.0.0.1` 뒤에 `:3000` 과 같은 숫자가 표현된다. 이 숫자는 IP주소가 가리키는 PC에 접속할 수있는 통로(채널)을 의미한다. 리액트를 실행했을 때에는 로컬 PC의 IP주소로 접근하여, 3000번의 통로를 통해 실행 중인 리액트를 확인할 수 있다. 이미 사용중은 포트는 중복해서 사용할 수 업ㄴㅅ다. 만약 다른 프로그램에서 3000번 포트를 사용 중이라면, 다음과 같이 다른 포트번호 (3001)로 리액트가 실행된다.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/1Bqoc6rAN-1620220055416.png)

포트번호는 0~65535까지 사용할 수 있다. 그 중에서 0~1024번까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있다. 반드시 알아야 할 잘 알려진 포트 번호는 다음과 같다.

* 22 : SSH
* 80 : HTTP
* 443 : HTTPS

더 많은 포트번호 확인하기 : https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers

이미 정해진 포트 번호라도, 필요에 따라 자유롭게 사용할 수 있다. HTTP(:80), HTTPS(:443)과 같이 잘 알려진 포트의 경우, `https://codestates.com:443` 이 아닌 `https://codestates.com` 처럼 포트 번호를 URI에 생략할 수 있지만, 그 외의 잘 알려지지 않은 포트 (3000과 같은 임시포트)는 반드시 포트 번호를 포함해야 한다.


## ✔️ 도메인과 DNS

### Domain name

웹 브라우저를 통해 특정 사이트에 진입을 할 때, IP주소를 대신하여 사용하는 주소가 있다. 만약 IP주소가 지번 또는 도로명 주소라면, 도메인 이름은 해당 주소에 위치한 상호로 볼 수 있다.

다음과 같이, 터미널에서 도메인 이름을 통해 IP주소를 확인하는 명령어 `nslookup`으로 codestates.com의 IP주소를 확인할 수 있다.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/lgpHkO1Ss-1620218482070.png)

위 그림에서 IP주소는 3.34.153.168 이고, 도메인 이름은 codestates.com이다. 주소창에 IP주소(3.34.153.168) 를 입력하면, codestates.com 으로 이동할 수 있다.

### DNS

네트워크 상에 존재하는 모든 PC는 IP주소가 있다. 그러나 모든 IP주소가 도메인 이름을 가지는 것은 아니다. 로컬 PC를 나타내는 `127.0.0.1` 은 `localhost` 로 사용할 수 있지만, 그 외의 모든 도메인 이름은 일정 기간 동안 대여하여 사용한다. 그렇다면 이렇게 대여한 도메인 이름과 IP주소는 어떻게 매칭하는 것일까?

브라우저의 검색창에 도메인 이름을 입력하여 해당 사이트로 이동하기 위해서는 도메인 이름과 매칭된 IP주소를 확인하는 작업이 반드시 필요하다. 네트워크에는 이것을 위한 서버가 별도로 있는데 이를 DNS(Domain Name System)이라고 한다.

DNS는 호스트의 도메인 이름을 IP주소로 변환하거나 반대의 경우를 수행할 수 있도록 개발된 데이터베이스 시스템이다. 만약 브라우저의 검색창에 naver.com을 입력한다면, 이 요청은 DNS에서 IP주소 (ex. 125.209.222.142)를 찾는다. 그리고 이 IP주소에 해당하는 웹 서버로 요청을 전달하여 클라이언트와 서버가 통신할 수 있도록 한다.

<br>

## ✔️ 크롬 브라우저 에러 읽기

<br>

크롬 브라우저를 사용하다 보면 누구나 한 번쯤 에러 메시지를 만날 수 있다. 이 에러 메시지는 웹페이지를 제공하는 서버와 크롬 브라우저가 소통하는 단계, 또는 기기와 네트워크의 연결, 크롬 브라우저가 해석할 수 없는 데이터를 전송받은 경우 발생한다. 아래에서 설명하는 에러 메시지는 크롬 브라우저를 사용하면 만날 수 있는 잘 알려진 에러 메시지이다. 크롬 브라우저를 제공하는 구글은 이런 에러 메시지를 어떻게 핸들링해야 하는지 잘 설명해두었다. 크롬 브라우저에서 에러 메시지를 만났을 때 어떤 에러인지 알아야 차분히 해결할 수 있을 것이다.

![](/capture/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-05-24%20%EC%98%A4%ED%9B%84%2012.42.50.png)

***