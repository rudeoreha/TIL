# [23.06.09] 코드스테이츠 (FE) 45기\_DAY 41

# Unit1 <br><br> 👩🏻‍💻 Chapter 1. 재귀의 이해

<br>

### 재귀의 개념

재귀란 : 원래의 자리로 되돌아가거나 되돌아옴. 이라는 뜻을 가지고 있다.

위의 정의와 예시를 참고하여 재귀를 코드로 표현하면 다음과 같이 작성해볼 수 있겠다.

```js
function recursion() {
  console.log("This is");
  console.log("recursion!");
  recursion();
}
```

이 함수를 호출하면 어떻게 될까요?

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/NPDmW6AzjzC5OpyQIr1JT-1655887050858.png)

`recursion` 함수를 호출했더니, 자기 자신을 끝없이 호출하면서 같은 코드가 계속해서 실행되는 것을 볼 수 있다. 이 `recursion` 함수처럼 자기 자신을 호출하는 함수를 재귀함수라고 한다. 재귀함수를 잘 활용하면 반복적인 작업을 해야하는 문제를 좀 더 간결한 코드로 풀어낼 수 있다.

### 재귀로 문제 해결하기

그렇다면 어떻게 하면 재귀를 활용해서 문제를 해결할 수 있는지 아래의 문제를 푸는 과정을 따라가 보면서 알아보자.

```
문제 : 자연수로 이루어진 리스트(배열)를 입력받고, 리스트의 합을 리턴하는 함수 `arrSum`을 작성하세요.
```

재귀로 문제를 해결하는 단계는 다음과 같다.

1. 문제를 좀 더 작게 쪼갠다.
2. 1번과 같은 방식으로, 문제가 더는 작아지지 않을 때까지, 가장 작은 단위로 문제를 쪼갠다.
3. 가장 작은 단위의 문제를 풂으로써 전체 문제를 해결한다.

이 단계를 적용해서 `arrSum` 함수를 작성해보자. 일단 배열 `[1, 2, 3, 4, 5]` 의 합을 구하는 과정을 재귀로 풀어보자.

<br>

#### 1. 문제를 작게 쪼개기

어떻게 하면 `arrSum` 함수로 `[1, 2, 3, 4, 5]`의 합을 구하는 과정을 더 작게 쪼갤 수 있을까?

단순하게 생각해보면 배열의 합을 구할 때, `[1, 2, 3, 4, 5]`의 합을 구하는 것보다 `[2, 3, 4, 5]` 의 합을 구하는 것이 더 작은 문제이고, 여기서 또 `[2, 3, 4, 5]`
의 합을 구하는 것보다 `[3, 4, 5]` 의 합을 구하는 것이 더 작은 문제일 것이다.

위 방식으로 문제를 쪼갠 것을 코드로 표현하면 다음과 같다.

```js
arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5])
arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5])
...
```

<br>

#### 2. 문제를 가장 작은 단위로 쪼개기

위에서 문제를 쪼갠 방식을 반복해서 문제를 계속해서 쪼개면 더 이상 쪼갤 수 없는 상태에 도달하게 된다.

```js
...
arrSum([3, 4, 5]) === 3 + arrSum([4, 5])
arrSum([4, 5]) === 4 + arrSum([5])
arrSum([5]) === 5 + arrSum([])
```

마지막에는 `arrSum` 이 빈 배열을 받게 되면서 더 이상 쪼갤 수 없게 된다. 이로써 문제를 가장 작은 단위까지 쪼갰다고 할 수 있다.

<br>

#### 3. 문제 해결하기

문제가 더 쪼개지지 않게 되면, 갖장 작은 단위의 문제를 해결한다. 문제를 쪼갤 때 같은 방식으로 쪼갰기 때문에, 가장 작은 단위의 문제를 해결한 방식으로 문제 전체를 해결할 수 있게 된다.

2번에서 도달한 가장 작은 문제는 `arrSum([])`이었다. 빈 배열의 합은 0이므로, 0을 리턴해줄것이다. 이렇게 가장 작은 문제를 해결하는 순간, 아래 코드처럼 쪼개졌던 문제가 거꾸로 거슬러 올라가면서 합쳐지게 된다.

```js
arrSum([]) === 0; // <-- 문제가 더는 작아지지 않는 순간
// 가장 작은 경우의 해결책을 적용합니다.
((arrSum([5]) === 5 + arrSum([])) === 5 + 0) === 5;
((arrSum([4, 5]) === 4 + arrSum([5])) === 4 + 5) === 9;
((arrSum([3, 4, 5]) === 3 + arrSum([4, 5])) === 3 + 9) === 12;
((arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5])) === 2 + 12) === 14;
((arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5])) === 1 + 14) === 15;
```

`arrSum` 함수의 리턴 값이 나오면서 연쇄적으로 문제가 해결되고, 최종적으로는 문제 전체가 해결되는 것을 볼 수 있다.

위 단계를 반영해서 `arrSum` 함수를 완성해보면 다음과 같다.

```js
function arrSum(arr) {
  // 빈 배열을 받았을 때 0을 리턴하는 조건문
  //   --> 가장 작은 문제를 해결하는 코드 & 재귀를 멈추는 코드
  if (arr.length === 0) {
    return 0;
  }

  // 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
  //   --> 재귀(자기 자신을 호출)를 통해 문제를 작게 쪼개나가는 코드
  return arr.shift() + arrSum(arr);
}
```

`arrSum` 함수가 작동하는 방식을 시각적으로 확인해보자.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/CepsiU3zOLo86Ih3cryF8-1655887226373.gif)

arrSum함수가 내부에서 arrSum함수를 호출하면서 문제가 쪼개어져 나가고, 결국 문제를 더 이상 쪼갤 수 없는 arrSum([])까지 함수가 호출되는 것을 볼 수 있다.

![](https://s3.ap-northeast-2.amazonaws.com/urclass-images/izJvDRkWEiMycLh075y5C-1655887266820.gif)

`arrSum([])` 는 조건문에 의해 더 이상 자기 자신을 호출하지 않고, 숫자 0을 리턴하면서 종료된다. 그 결과 중첩되어 있던 함수들도 연쇄적으로 숫자를 리턴하고, 최종적으로는 배열의 모든 요소의 합을 리턴하면서 문제가 해결된다.

<br>

### 재귀는 언제 사용하는 게 좋을까?

재귀는 다음과 같은 상황에서 매우 적합하다.

1. 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우
2. 중첩된 반복문이 많거나 반복문의 중첩횟수 (number of loop)를 예측하기 어려운 경우

```js
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    for (let k = 0; k < n; k++) {
      for (let l = 0; l < n; l++) {
        for (let m = 0; m < n; m++) {
          for (let n = 0; n < n; n++) {
            for (let o = 0; o < n; o++) {
              for (let p = 0; p < n; p++) {
                // do something
                someFunc(i, j, k, l, m, n, o, p);
              }
            }
          }
        }
      }
    }
  }
}
```

모든 재귀함수는 반복문(`while`문 또는 `for`문)으로 표현할 수 있다. 그러나 재귀를 적용할 수 있는 대부분의 경우에는, 재귀를 적용한 코드가 더욱 간결하고 이해하기 쉽다.

이 밖에도, 재귀는 알고리즘 문제의 많은 부분을 차지한다.

<br>

# 👩🏻‍💻 Chapter 2. 재귀의 활용

### Guide : 재귀적으로 사고하기

<br>

#### 1. 재귀 함수의 입력값과 출력값 정의하기

재귀적으로 사고하는 데에 가장 먼저 해야 할 일은 문제를 가장 추상적으로 또는, 가장 단순하게 정의하는 것이다. 함수의 입출력 값을 정의하는 것은 그 첫 출발점이며, 재귀 함수를 통해 풀고자 하는 문제, 즉 도달하고자 하는 목표를 정의하는데 도움이 된다.

함수 `arrSum`의 경우 `number` 타입을 요소로 갖는 배열을 입력으로 받고, `number` 타입을 리턴한다. 이를 좀 더 간단하게 표기하면 다음과 같다.

```js
arrSum: [number] => number // <= 입출력 값 정의
```

<br>

#### 2. 문제를 쪼개고 경우의 수를 나누기

다음으로는 주어진 문제를 어떻게 쪼갤 것인지 고민한다. 문제를 쪼갤 기준을 정하고, 정한 기준에 따라 문제를 더 큰 경우와 작은 경우로 구분할 수 있는지 확인한다. 일반적으로, 입력값을 이 기준으로 정한다. 이때 중요한 관점은 **입력값이나 문제의 순서와 크기**이다. 주어진 입력값 또는 문제 상황을 크기로 구분할 수 있거나, 순서를 명확하게 정할 수 있다면 문제를 구분하는 데 도움이 된다. 그리고 구분된 문제를 푸는 방식이 순서나 크기와 관계없이 모두 같다면, 문제를 제대로 구분한 것이다.

- 함수 `arrSum` 의 경우 입력값인 배열의 크기에 따라, 더 작은 문제로 나눌 수 있다. 그리고 `arrSum([1, 2, 3, 4])`를 구하는 방법과 `arrSum([2, 3, 4])`를 구하는 방법은 동일하므로, 이 구분은 적절하다고 판단할 수 있다.

이제 문제에서 주어진 입력값에 따라, 경우의 수를 나눈다. 일반적으로 문제를 더 이상 쪼갤 수 없는 경우와 그렇지 않는 경우로 나눈다.

- 함수 `arrSum` 은 입력값이 빈 배열인 경우와 그렇지 않은 경우로 나눌 수 있다. 각각의 경우는 다른 방식으로 처리해야 한다.

  - `arrSum : [number] => number`
  - `arrSum([ ])` <- 입력값이 빈 배열인 경우
  - `arrSum([요소1, 요소2, ... 요소n])` <- 그렇지 않은 경우

<br>

#### 3. 단순한 문제 해결하기

문제를 여러 경우로 구분한 다음에는, 가장 해결하기 쉬운 문제부터 해결한다. 이를 재귀의 기초(base case)라고 부른다. 재귀의 기초는 나중에 재귀함수를 구현할 때, 재귀의 탈출조건(재귀 호출이 멈추는 조건)을 구성한다.

탈출조건이 없는 경우 재귀 함수는 끝없이 자기 자신을 호출하게 된다. 그렇다고 문제를 덜 쪼갠 상태에서 탈출 조건을 세우는 경우 문제를 제대로 해결할 수 없게 된다. 그만큼 문제를 최대한 작게 쪼갠 후에 문제를 해결하는 것이 중요하다.

- 함수 `arrSum` 을 더 이상 쪼갤 수 없는 경우는 입력값이 빈 배열일 경우이고, 이때 `arrSum([])` 의 리턴값은 0이다.
  - `arrSum : [number] => number`
  - `arrSum([ ]) === 0` <- 입력값이 빈 배열인 경우 : 해결!
  - `arrSum([요소1, 요소2, ... 요소n])`

<br>

#### 4. 복잡한 문제 해결하기

남아있는 복잡한 경우를 해결한다.

- 길이가 1 이상인 배열이 함수 `arrSum` 에 입력된 경우, 입력된 배열을 배열의 첫 요소와 나머지 요소를 입력값으로 갖는 문제로 쪼개고, 둘을 더한다.
- `arrSum : [number] => number`
- `arrSum([ ]) === 0`
- `arrSum([요소1, 요소2, ... 요소n]) === 요소1 + arrSum([요소2, ..., 요소 n])` <- 그렇지 않은 경우 : 해결!
- 배열을 첫 요소와 더 작은 문제로 쪼개는 방법만 안다면, 함수 `arrSum` 을 재귀적으로 구현할 수 있다.

<br>

#### 5. 코드 구현하기

```js
function arrSum(arr) {
  // base case : 문제를 더 이상 쪼갤 수 없는 경우 (재귀의 기초)
  if (arr의 길이가 0인 경우) {
    return 0;
  }

  // recursive case : 그렇지 않은 경우
  return 요소1 + arrSum([요소2, ... , 요소n]);
}
```

아래는 일반적인 재귀 함수의 템플릿이다. 재귀 함수 연습에 활용하자.

```js
function recursive(input1, input2, ...) {
  // base case : 문제를 더 이상 쪼갤 수 없는 경우
  if (문제를 더 이상 쪼갤 수 없을 경우) {
    return 단순한 문제의 해답;
  }

  // recursive case : 그렇지 않은 경우
  return 더 작은 문제로 새롭게 정의된 문제
}
```

---

## 👩🏻‍💻 예제

---

이번 예제에서는 재귀를 활용해서 factorial 문제를 풀어보도록 하자.

```js
// 문제 : 자연수를 입력받고, 입력받은 수부터 1까지의 자연수를 모두 곱한 값을 리턴하는 재귀함수 `fac` 을 작성하세요.

예1) fac(5) === 5 * 4 * 3 * 2 * 1 === 120
예2) fac(3) === 3 * 2 * 1 === 6


function fac(n) {
    if (n === 1) {
        return 1;
    }

    return n * fac(n-1);
}
```

<br>
